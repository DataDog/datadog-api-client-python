# coding: utf-8

# Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
# This product includes software developed at Datadog (https://www.datadoghq.com/).
# Copyright 2019-Present Datadog, Inc.


from __future__ import absolute_import

import logging
import re  # noqa: F401
import sys  # noqa: F401

# python 2 and python 3 compatibility library
import six

from datadog_api_client.v1.api_client import ApiClient
from datadog_api_client.v1.exceptions import (
    ApiTypeError,
    ApiValueError
)
from datadog_api_client.v1.model_utils import (  # noqa: F401
    check_allowed_values,
    check_validations,
    date,
    datetime,
    file_type,
    int,
    none_type,
    str,
    validate_and_convert_types
)
from datadog_api_client.v1.model import api_error_response
from datadog_api_client.v1.model import usage_analyzed_logs_response
from datadog_api_client.v1.model import usage_fargate_response
from datadog_api_client.v1.model import usage_hosts_response
from datadog_api_client.v1.model import usage_lambda_response
from datadog_api_client.v1.model import usage_logs_response
from datadog_api_client.v1.model import usage_logs_by_index_response
from datadog_api_client.v1.model import usage_network_flows_response
from datadog_api_client.v1.model import usage_network_hosts_response
from datadog_api_client.v1.model import usage_rum_sessions_response
from datadog_api_client.v1.model import usage_snmp_response
from datadog_api_client.v1.model import usage_summary_response
from datadog_api_client.v1.model import usage_synthetics_response
from datadog_api_client.v1.model import usage_synthetics_api_response
from datadog_api_client.v1.model import usage_synthetics_browser_response
from datadog_api_client.v1.model import usage_timeseries_response
from datadog_api_client.v1.model import usage_top_avg_metrics_response
from datadog_api_client.v1.model import usage_trace_response

logger = logging.getLogger(__name__)


class UsageMeteringApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

        def __get_usage_analyzed_logs(
            self,
            start_hr,
            **kwargs
        ):
            """Get hourly usage for analyzed logs  # noqa: E501

            Get hourly usage for analyzed logs (Security Monitoring).  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.get_usage_analyzed_logs(start_hr, async_req=True)
            >>> result = thread.get()

            Args:
                start_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: &#x60;[YYYY-MM-DDThh]&#x60; for usage beginning at this hour.

            Keyword Args:
                end_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: &#x60;[YYYY-MM-DDThh]&#x60; for usage ending **before** this hour.. [optional]
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                usage_analyzed_logs_response.UsageAnalyzedLogsResponse
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            kwargs['start_hr'] = \
                start_hr
            return self.call_with_http_info(**kwargs)

        self.get_usage_analyzed_logs = Endpoint(
            settings={
                'response_type': (usage_analyzed_logs_response.UsageAnalyzedLogsResponse,),
                'auth': [
                    'apiKeyAuth',
                    'appKeyAuth'
                ],
                'endpoint_path': '/api/v1/usage/analyzed_logs',
                'operation_id': 'get_usage_analyzed_logs',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'start_hr',
                    'end_hr',
                ],
                'required': [
                    'start_hr',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'start_hr':
                        (datetime,),
                    'end_hr':
                        (datetime,),
                },
                'attribute_map': {
                    'start_hr': 'start_hr',
                    'end_hr': 'end_hr',
                },
                'location_map': {
                    'start_hr': 'query',
                    'end_hr': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json;datetime-format=rfc3339'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__get_usage_analyzed_logs
        )

        def __get_usage_fargate(
            self,
            start_hr,
            **kwargs
        ):
            """Get hourly usage for Fargate  # noqa: E501

            Get hourly usage for [Fargate](https://docs.datadoghq.com/integrations/ecs_fargate/).  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.get_usage_fargate(start_hr, async_req=True)
            >>> result = thread.get()

            Args:
                start_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage beginning at this hour.

            Keyword Args:
                end_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage ending **before** this hour.. [optional]
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                usage_fargate_response.UsageFargateResponse
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            kwargs['start_hr'] = \
                start_hr
            return self.call_with_http_info(**kwargs)

        self.get_usage_fargate = Endpoint(
            settings={
                'response_type': (usage_fargate_response.UsageFargateResponse,),
                'auth': [
                    'apiKeyAuth',
                    'appKeyAuth'
                ],
                'endpoint_path': '/api/v1/usage/fargate',
                'operation_id': 'get_usage_fargate',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'start_hr',
                    'end_hr',
                ],
                'required': [
                    'start_hr',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'start_hr':
                        (datetime,),
                    'end_hr':
                        (datetime,),
                },
                'attribute_map': {
                    'start_hr': 'start_hr',
                    'end_hr': 'end_hr',
                },
                'location_map': {
                    'start_hr': 'query',
                    'end_hr': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json;datetime-format=rfc3339'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__get_usage_fargate
        )

        def __get_usage_hosts(
            self,
            start_hr,
            **kwargs
        ):
            """Get hourly usage for hosts and containers  # noqa: E501

            Get hourly usage for hosts and containers.  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.get_usage_hosts(start_hr, async_req=True)
            >>> result = thread.get()

            Args:
                start_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage beginning at this hour.

            Keyword Args:
                end_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage ending **before** this hour.. [optional]
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                usage_hosts_response.UsageHostsResponse
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            kwargs['start_hr'] = \
                start_hr
            return self.call_with_http_info(**kwargs)

        self.get_usage_hosts = Endpoint(
            settings={
                'response_type': (usage_hosts_response.UsageHostsResponse,),
                'auth': [
                    'apiKeyAuth',
                    'appKeyAuth'
                ],
                'endpoint_path': '/api/v1/usage/hosts',
                'operation_id': 'get_usage_hosts',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'start_hr',
                    'end_hr',
                ],
                'required': [
                    'start_hr',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'start_hr':
                        (datetime,),
                    'end_hr':
                        (datetime,),
                },
                'attribute_map': {
                    'start_hr': 'start_hr',
                    'end_hr': 'end_hr',
                },
                'location_map': {
                    'start_hr': 'query',
                    'end_hr': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json;datetime-format=rfc3339'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__get_usage_hosts
        )

        def __get_usage_lambda(
            self,
            start_hr,
            **kwargs
        ):
            """Get hourly usage for Lambda  # noqa: E501

            Get hourly usage for lambda.  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.get_usage_lambda(start_hr, async_req=True)
            >>> result = thread.get()

            Args:
                start_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage beginning at this hour.

            Keyword Args:
                end_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage ending **before** this hour.. [optional]
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                usage_lambda_response.UsageLambdaResponse
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            kwargs['start_hr'] = \
                start_hr
            return self.call_with_http_info(**kwargs)

        self.get_usage_lambda = Endpoint(
            settings={
                'response_type': (usage_lambda_response.UsageLambdaResponse,),
                'auth': [
                    'apiKeyAuth',
                    'appKeyAuth'
                ],
                'endpoint_path': '/api/v1/usage/aws_lambda',
                'operation_id': 'get_usage_lambda',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'start_hr',
                    'end_hr',
                ],
                'required': [
                    'start_hr',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'start_hr':
                        (datetime,),
                    'end_hr':
                        (datetime,),
                },
                'attribute_map': {
                    'start_hr': 'start_hr',
                    'end_hr': 'end_hr',
                },
                'location_map': {
                    'start_hr': 'query',
                    'end_hr': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json;datetime-format=rfc3339'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__get_usage_lambda
        )

        def __get_usage_logs(
            self,
            start_hr,
            **kwargs
        ):
            """Get hourly usage for Logs  # noqa: E501

            Get hourly usage for logs.  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.get_usage_logs(start_hr, async_req=True)
            >>> result = thread.get()

            Args:
                start_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage beginning at this hour.

            Keyword Args:
                end_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage ending **before** this hour.. [optional]
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                usage_logs_response.UsageLogsResponse
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            kwargs['start_hr'] = \
                start_hr
            return self.call_with_http_info(**kwargs)

        self.get_usage_logs = Endpoint(
            settings={
                'response_type': (usage_logs_response.UsageLogsResponse,),
                'auth': [
                    'apiKeyAuth',
                    'appKeyAuth'
                ],
                'endpoint_path': '/api/v1/usage/logs',
                'operation_id': 'get_usage_logs',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'start_hr',
                    'end_hr',
                ],
                'required': [
                    'start_hr',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'start_hr':
                        (datetime,),
                    'end_hr':
                        (datetime,),
                },
                'attribute_map': {
                    'start_hr': 'start_hr',
                    'end_hr': 'end_hr',
                },
                'location_map': {
                    'start_hr': 'query',
                    'end_hr': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json;datetime-format=rfc3339'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__get_usage_logs
        )

        def __get_usage_logs_by_index(
            self,
            start_hr,
            **kwargs
        ):
            """Get hourly usage for Logs by Index  # noqa: E501

            Get hourly usage for logs by index.  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.get_usage_logs_by_index(start_hr, async_req=True)
            >>> result = thread.get()

            Args:
                start_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage beginning at this hour.

            Keyword Args:
                end_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage ending **before** this hour.. [optional]
                index_name ([str]): Comma-separated list of log index names.. [optional]
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                usage_logs_by_index_response.UsageLogsByIndexResponse
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            kwargs['start_hr'] = \
                start_hr
            return self.call_with_http_info(**kwargs)

        self.get_usage_logs_by_index = Endpoint(
            settings={
                'response_type': (usage_logs_by_index_response.UsageLogsByIndexResponse,),
                'auth': [
                    'apiKeyAuth',
                    'appKeyAuth'
                ],
                'endpoint_path': '/api/v1/usage/logs_by_index',
                'operation_id': 'get_usage_logs_by_index',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'start_hr',
                    'end_hr',
                    'index_name',
                ],
                'required': [
                    'start_hr',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'start_hr':
                        (datetime,),
                    'end_hr':
                        (datetime,),
                    'index_name':
                        ([str],),
                },
                'attribute_map': {
                    'start_hr': 'start_hr',
                    'end_hr': 'end_hr',
                    'index_name': 'index_name',
                },
                'location_map': {
                    'start_hr': 'query',
                    'end_hr': 'query',
                    'index_name': 'query',
                },
                'collection_format_map': {
                    'index_name': 'multi',
                }
            },
            headers_map={
                'accept': [
                    'application/json;datetime-format=rfc3339'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__get_usage_logs_by_index
        )

        def __get_usage_network_flows(
            self,
            start_hr,
            **kwargs
        ):
            """Get hourly usage for Network Flows  # noqa: E501

            Get hourly usage for network flows.  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.get_usage_network_flows(start_hr, async_req=True)
            >>> result = thread.get()

            Args:
                start_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: &#x60;[YYYY-MM-DDThh]&#x60; for usage beginning at this hour.

            Keyword Args:
                end_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: &#x60;[YYYY-MM-DDThh]&#x60; for usage ending **before** this hour.. [optional]
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                usage_network_flows_response.UsageNetworkFlowsResponse
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            kwargs['start_hr'] = \
                start_hr
            return self.call_with_http_info(**kwargs)

        self.get_usage_network_flows = Endpoint(
            settings={
                'response_type': (usage_network_flows_response.UsageNetworkFlowsResponse,),
                'auth': [
                    'apiKeyAuth',
                    'appKeyAuth'
                ],
                'endpoint_path': '/api/v1/usage/network_flows',
                'operation_id': 'get_usage_network_flows',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'start_hr',
                    'end_hr',
                ],
                'required': [
                    'start_hr',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'start_hr':
                        (datetime,),
                    'end_hr':
                        (datetime,),
                },
                'attribute_map': {
                    'start_hr': 'start_hr',
                    'end_hr': 'end_hr',
                },
                'location_map': {
                    'start_hr': 'query',
                    'end_hr': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json;datetime-format=rfc3339'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__get_usage_network_flows
        )

        def __get_usage_network_hosts(
            self,
            start_hr,
            **kwargs
        ):
            """Get hourly usage for Network Hosts  # noqa: E501

            Get hourly usage for network hosts.  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.get_usage_network_hosts(start_hr, async_req=True)
            >>> result = thread.get()

            Args:
                start_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage beginning at this hour.

            Keyword Args:
                end_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage ending **before** this hour.. [optional]
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                usage_network_hosts_response.UsageNetworkHostsResponse
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            kwargs['start_hr'] = \
                start_hr
            return self.call_with_http_info(**kwargs)

        self.get_usage_network_hosts = Endpoint(
            settings={
                'response_type': (usage_network_hosts_response.UsageNetworkHostsResponse,),
                'auth': [
                    'apiKeyAuth',
                    'appKeyAuth'
                ],
                'endpoint_path': '/api/v1/usage/network_hosts',
                'operation_id': 'get_usage_network_hosts',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'start_hr',
                    'end_hr',
                ],
                'required': [
                    'start_hr',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'start_hr':
                        (datetime,),
                    'end_hr':
                        (datetime,),
                },
                'attribute_map': {
                    'start_hr': 'start_hr',
                    'end_hr': 'end_hr',
                },
                'location_map': {
                    'start_hr': 'query',
                    'end_hr': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json;datetime-format=rfc3339'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__get_usage_network_hosts
        )

        def __get_usage_rum_sessions(
            self,
            start_hr,
            **kwargs
        ):
            """Get hourly usage for RUM Sessions  # noqa: E501

            Get hourly usage for [RUM](https://docs.datadoghq.com/real_user_monitoring/) Sessions.  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.get_usage_rum_sessions(start_hr, async_req=True)
            >>> result = thread.get()

            Args:
                start_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage beginning at this hour.

            Keyword Args:
                end_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage ending **before** this hour.. [optional]
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                usage_rum_sessions_response.UsageRumSessionsResponse
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            kwargs['start_hr'] = \
                start_hr
            return self.call_with_http_info(**kwargs)

        self.get_usage_rum_sessions = Endpoint(
            settings={
                'response_type': (usage_rum_sessions_response.UsageRumSessionsResponse,),
                'auth': [
                    'apiKeyAuth',
                    'appKeyAuth'
                ],
                'endpoint_path': '/api/v1/usage/rum_sessions',
                'operation_id': 'get_usage_rum_sessions',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'start_hr',
                    'end_hr',
                ],
                'required': [
                    'start_hr',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'start_hr':
                        (datetime,),
                    'end_hr':
                        (datetime,),
                },
                'attribute_map': {
                    'start_hr': 'start_hr',
                    'end_hr': 'end_hr',
                },
                'location_map': {
                    'start_hr': 'query',
                    'end_hr': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json;datetime-format=rfc3339'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__get_usage_rum_sessions
        )

        def __get_usage_snmp(
            self,
            start_hr,
            **kwargs
        ):
            """Get hourly usage for SNMP devices  # noqa: E501

            Get hourly usage for SNMP devices.  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.get_usage_snmp(start_hr, async_req=True)
            >>> result = thread.get()

            Args:
                start_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: &#x60;[YYYY-MM-DDThh]&#x60; for usage beginning at this hour.

            Keyword Args:
                end_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: &#x60;[YYYY-MM-DDThh]&#x60; for usage ending **before** this hour.. [optional]
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                usage_snmp_response.UsageSNMPResponse
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            kwargs['start_hr'] = \
                start_hr
            return self.call_with_http_info(**kwargs)

        self.get_usage_snmp = Endpoint(
            settings={
                'response_type': (usage_snmp_response.UsageSNMPResponse,),
                'auth': [
                    'apiKeyAuth',
                    'appKeyAuth'
                ],
                'endpoint_path': '/api/v1/usage/snmp',
                'operation_id': 'get_usage_snmp',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'start_hr',
                    'end_hr',
                ],
                'required': [
                    'start_hr',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'start_hr':
                        (datetime,),
                    'end_hr':
                        (datetime,),
                },
                'attribute_map': {
                    'start_hr': 'start_hr',
                    'end_hr': 'end_hr',
                },
                'location_map': {
                    'start_hr': 'query',
                    'end_hr': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json;datetime-format=rfc3339'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__get_usage_snmp
        )

        def __get_usage_summary(
            self,
            start_month,
            **kwargs
        ):
            """Get usage across your multi-org account  # noqa: E501

            Get usage across your multi-org account.  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.get_usage_summary(start_month, async_req=True)
            >>> result = thread.get()

            Args:
                start_month (datetime): Datetime in ISO-8601 format, UTC, precise to month: &#x60;[YYYY-MM]&#x60; for usage beginning in this month. Maximum of 15 months ago.

            Keyword Args:
                end_month (datetime): Datetime in ISO-8601 format, UTC, precise to month: &#x60;[YYYY-MM]&#x60; for usage ending this month.. [optional]
                include_org_details (bool): Include usage summaries for each sub-org.. [optional]
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                usage_summary_response.UsageSummaryResponse
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            kwargs['start_month'] = \
                start_month
            return self.call_with_http_info(**kwargs)

        self.get_usage_summary = Endpoint(
            settings={
                'response_type': (usage_summary_response.UsageSummaryResponse,),
                'auth': [
                    'apiKeyAuth',
                    'appKeyAuth'
                ],
                'endpoint_path': '/api/v1/usage/summary',
                'operation_id': 'get_usage_summary',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'start_month',
                    'end_month',
                    'include_org_details',
                ],
                'required': [
                    'start_month',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'start_month':
                        (datetime,),
                    'end_month':
                        (datetime,),
                    'include_org_details':
                        (bool,),
                },
                'attribute_map': {
                    'start_month': 'start_month',
                    'end_month': 'end_month',
                    'include_org_details': 'include_org_details',
                },
                'location_map': {
                    'start_month': 'query',
                    'end_month': 'query',
                    'include_org_details': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json;datetime-format=rfc3339'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__get_usage_summary
        )

        def __get_usage_synthetics(
            self,
            start_hr,
            **kwargs
        ):
            """Get hourly usage for Synthetics API Checks  # noqa: E501

            Get hourly usage for [Synthetics API checks](https://docs.datadoghq.com/synthetics/).  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.get_usage_synthetics(start_hr, async_req=True)
            >>> result = thread.get()

            Args:
                start_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage beginning at this hour.

            Keyword Args:
                end_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage ending **before** this hour.. [optional]
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                usage_synthetics_response.UsageSyntheticsResponse
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            kwargs['start_hr'] = \
                start_hr
            return self.call_with_http_info(**kwargs)

        self.get_usage_synthetics = Endpoint(
            settings={
                'response_type': (usage_synthetics_response.UsageSyntheticsResponse,),
                'auth': [
                    'apiKeyAuth',
                    'appKeyAuth'
                ],
                'endpoint_path': '/api/v1/usage/synthetics',
                'operation_id': 'get_usage_synthetics',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'start_hr',
                    'end_hr',
                ],
                'required': [
                    'start_hr',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'start_hr':
                        (datetime,),
                    'end_hr':
                        (datetime,),
                },
                'attribute_map': {
                    'start_hr': 'start_hr',
                    'end_hr': 'end_hr',
                },
                'location_map': {
                    'start_hr': 'query',
                    'end_hr': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json;datetime-format=rfc3339'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__get_usage_synthetics
        )

        def __get_usage_synthetics_api(
            self,
            start_hr,
            **kwargs
        ):
            """Get hourly usage for Synthetics API Checks  # noqa: E501

            Get hourly usage for [synthetics API checks](https://docs.datadoghq.com/synthetics/).  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.get_usage_synthetics_api(start_hr, async_req=True)
            >>> result = thread.get()

            Args:
                start_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage beginning at this hour.

            Keyword Args:
                end_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage ending **before** this hour.. [optional]
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                usage_synthetics_api_response.UsageSyntheticsAPIResponse
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            kwargs['start_hr'] = \
                start_hr
            return self.call_with_http_info(**kwargs)

        self.get_usage_synthetics_api = Endpoint(
            settings={
                'response_type': (usage_synthetics_api_response.UsageSyntheticsAPIResponse,),
                'auth': [
                    'apiKeyAuth',
                    'appKeyAuth'
                ],
                'endpoint_path': '/api/v1/usage/synthetics_api',
                'operation_id': 'get_usage_synthetics_api',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'start_hr',
                    'end_hr',
                ],
                'required': [
                    'start_hr',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'start_hr':
                        (datetime,),
                    'end_hr':
                        (datetime,),
                },
                'attribute_map': {
                    'start_hr': 'start_hr',
                    'end_hr': 'end_hr',
                },
                'location_map': {
                    'start_hr': 'query',
                    'end_hr': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json;datetime-format=rfc3339'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__get_usage_synthetics_api
        )

        def __get_usage_synthetics_browser(
            self,
            start_hr,
            **kwargs
        ):
            """Get hourly usage for Synthetics Browser Checks  # noqa: E501

            Get hourly usage for synthetics browser checks.  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.get_usage_synthetics_browser(start_hr, async_req=True)
            >>> result = thread.get()

            Args:
                start_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage beginning at this hour.

            Keyword Args:
                end_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage ending **before** this hour.. [optional]
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                usage_synthetics_browser_response.UsageSyntheticsBrowserResponse
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            kwargs['start_hr'] = \
                start_hr
            return self.call_with_http_info(**kwargs)

        self.get_usage_synthetics_browser = Endpoint(
            settings={
                'response_type': (usage_synthetics_browser_response.UsageSyntheticsBrowserResponse,),
                'auth': [
                    'apiKeyAuth',
                    'appKeyAuth'
                ],
                'endpoint_path': '/api/v1/usage/synthetics_browser',
                'operation_id': 'get_usage_synthetics_browser',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'start_hr',
                    'end_hr',
                ],
                'required': [
                    'start_hr',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'start_hr':
                        (datetime,),
                    'end_hr':
                        (datetime,),
                },
                'attribute_map': {
                    'start_hr': 'start_hr',
                    'end_hr': 'end_hr',
                },
                'location_map': {
                    'start_hr': 'query',
                    'end_hr': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json;datetime-format=rfc3339'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__get_usage_synthetics_browser
        )

        def __get_usage_timeseries(
            self,
            start_hr,
            **kwargs
        ):
            """Get hourly usage for custom metrics  # noqa: E501

            Get hourly usage for [custom metrics](https://docs.datadoghq.com/developers/metrics/custom_metrics/).  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.get_usage_timeseries(start_hr, async_req=True)
            >>> result = thread.get()

            Args:
                start_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage beginning at this hour.

            Keyword Args:
                end_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage ending **before** this hour.. [optional]
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                usage_timeseries_response.UsageTimeseriesResponse
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            kwargs['start_hr'] = \
                start_hr
            return self.call_with_http_info(**kwargs)

        self.get_usage_timeseries = Endpoint(
            settings={
                'response_type': (usage_timeseries_response.UsageTimeseriesResponse,),
                'auth': [
                    'apiKeyAuth',
                    'appKeyAuth'
                ],
                'endpoint_path': '/api/v1/usage/timeseries',
                'operation_id': 'get_usage_timeseries',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'start_hr',
                    'end_hr',
                ],
                'required': [
                    'start_hr',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'start_hr':
                        (datetime,),
                    'end_hr':
                        (datetime,),
                },
                'attribute_map': {
                    'start_hr': 'start_hr',
                    'end_hr': 'end_hr',
                },
                'location_map': {
                    'start_hr': 'query',
                    'end_hr': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json;datetime-format=rfc3339'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__get_usage_timeseries
        )

        def __get_usage_top_avg_metrics(
            self,
            month,
            **kwargs
        ):
            """Get top 500 custom metrics by hourly average  # noqa: E501

            Get top [custom metrics](https://docs.datadoghq.com/developers/metrics/custom_metrics/) by hourly average.  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.get_usage_top_avg_metrics(month, async_req=True)
            >>> result = thread.get()

            Args:
                month (datetime): Datetime in ISO-8601 format, UTC, precise to month: [YYYY-MM] for usage beginning at this hour.

            Keyword Args:
                names ([str]): Comma-separated list of metric names.. [optional]
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                usage_top_avg_metrics_response.UsageTopAvgMetricsResponse
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            kwargs['month'] = \
                month
            return self.call_with_http_info(**kwargs)

        self.get_usage_top_avg_metrics = Endpoint(
            settings={
                'response_type': (usage_top_avg_metrics_response.UsageTopAvgMetricsResponse,),
                'auth': [
                    'apiKeyAuth',
                    'appKeyAuth'
                ],
                'endpoint_path': '/api/v1/usage/top_avg_metrics',
                'operation_id': 'get_usage_top_avg_metrics',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'month',
                    'names',
                ],
                'required': [
                    'month',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'month':
                        (datetime,),
                    'names':
                        ([str],),
                },
                'attribute_map': {
                    'month': 'month',
                    'names': 'names',
                },
                'location_map': {
                    'month': 'query',
                    'names': 'query',
                },
                'collection_format_map': {
                    'names': 'multi',
                }
            },
            headers_map={
                'accept': [
                    'application/json;datetime-format=rfc3339'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__get_usage_top_avg_metrics
        )

        def __get_usage_trace(
            self,
            start_hr,
            **kwargs
        ):
            """Get hourly usage for Trace Search  # noqa: E501

            Get hourly usage for trace search.  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.get_usage_trace(start_hr, async_req=True)
            >>> result = thread.get()

            Args:
                start_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage beginning at this hour.

            Keyword Args:
                end_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage ending **before** this hour.. [optional]
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                usage_trace_response.UsageTraceResponse
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            kwargs['start_hr'] = \
                start_hr
            return self.call_with_http_info(**kwargs)

        self.get_usage_trace = Endpoint(
            settings={
                'response_type': (usage_trace_response.UsageTraceResponse,),
                'auth': [
                    'apiKeyAuth',
                    'appKeyAuth'
                ],
                'endpoint_path': '/api/v1/usage/traces',
                'operation_id': 'get_usage_trace',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'start_hr',
                    'end_hr',
                ],
                'required': [
                    'start_hr',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'start_hr':
                        (datetime,),
                    'end_hr':
                        (datetime,),
                },
                'attribute_map': {
                    'start_hr': 'start_hr',
                    'end_hr': 'end_hr',
                },
                'location_map': {
                    'start_hr': 'query',
                    'end_hr': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json;datetime-format=rfc3339'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__get_usage_trace
        )


class Endpoint(object):
    def __init__(self, settings=None, params_map=None, root_map=None,
                 headers_map=None, api_client=None, callable=None):
        """Creates an endpoint

        Args:
            settings (dict): see below key value pairs
                'response_type' (tuple/None): response type
                'auth' (list): a list of auth type keys
                'endpoint_path' (str): the endpoint path
                'operation_id' (str): endpoint string identifier
                'http_method' (str): POST/PUT/PATCH/GET etc
                'servers' (list): list of str servers that this endpoint is at
            params_map (dict): see below key value pairs
                'all' (list): list of str endpoint parameter names
                'required' (list): list of required parameter names
                'nullable' (list): list of nullable parameter names
                'enum' (list): list of parameters with enum values
                'validation' (list): list of parameters with validations
            root_map
                'validations' (dict): the dict mapping endpoint parameter tuple
                    paths to their validation dictionaries
                'allowed_values' (dict): the dict mapping endpoint parameter
                    tuple paths to their allowed_values (enum) dictionaries
                'openapi_types' (dict): param_name to openapi type
                'attribute_map' (dict): param_name to camelCase name
                'location_map' (dict): param_name to  'body', 'file', 'form',
                    'header', 'path', 'query'
                collection_format_map (dict): param_name to `csv` etc.
            headers_map (dict): see below key value pairs
                'accept' (list): list of Accept header strings
                'content_type' (list): list of Content-Type header strings
            api_client (ApiClient) api client instance
            callable (function): the function which is invoked when the
                Endpoint is called
        """
        self.settings = settings
        self.params_map = params_map
        self.params_map['all'].extend([
            'async_req',
            '_host_index',
            '_preload_content',
            '_request_timeout',
            '_return_http_data_only',
            '_check_input_type',
            '_check_return_type'
        ])
        self.params_map['nullable'].extend(['_request_timeout'])
        self.validations = root_map['validations']
        self.allowed_values = root_map['allowed_values']
        self.openapi_types = root_map['openapi_types']
        extra_types = {
            'async_req': (bool,),
            '_host_index': (none_type, int),
            '_preload_content': (bool,),
            '_request_timeout': (none_type, int, (int,), [int]),
            '_return_http_data_only': (bool,),
            '_check_input_type': (bool,),
            '_check_return_type': (bool,)
        }
        self.openapi_types.update(extra_types)
        self.attribute_map = root_map['attribute_map']
        self.location_map = root_map['location_map']
        self.collection_format_map = root_map['collection_format_map']
        self.headers_map = headers_map
        self.api_client = api_client
        self.callable = callable

    def __validate_inputs(self, kwargs):
        for param in self.params_map['enum']:
            if param in kwargs:
                check_allowed_values(
                    self.allowed_values,
                    (param,),
                    kwargs[param]
                )

        for param in self.params_map['validation']:
            if param in kwargs:
                check_validations(
                    self.validations,
                    (param,),
                    kwargs[param],
                    configuration=self.api_client.configuration
                )

        if kwargs['_check_input_type'] is False:
            return

        for key, value in six.iteritems(kwargs):
            fixed_val = validate_and_convert_types(
                value,
                self.openapi_types[key],
                [key],
                False,
                kwargs['_check_input_type'],
                configuration=self.api_client.configuration
            )
            kwargs[key] = fixed_val

    def __gather_params(self, kwargs):
        params = {
            'body': None,
            'collection_format': {},
            'file': {},
            'form': [],
            'header': {},
            'path': {},
            'query': []
        }

        for param_name, param_value in six.iteritems(kwargs):
            param_location = self.location_map.get(param_name)
            if param_location is None:
                continue
            if param_location:
                if param_location == 'body':
                    params['body'] = param_value
                    continue
                base_name = self.attribute_map[param_name]
                if (param_location == 'form' and
                        self.openapi_types[param_name] == (file_type,)):
                    params['file'][param_name] = [param_value]
                elif (param_location == 'form' and
                        self.openapi_types[param_name] == ([file_type],)):
                    # param_value is already a list
                    params['file'][param_name] = param_value
                elif param_location in {'form', 'query'}:
                    param_value_full = (base_name, param_value)
                    params[param_location].append(param_value_full)
                if param_location not in {'form', 'query'}:
                    params[param_location][base_name] = param_value
                collection_format = self.collection_format_map.get(param_name)
                if collection_format:
                    params['collection_format'][base_name] = collection_format

        return params

    def __call__(self, *args, **kwargs):
        """ This method is invoked when endpoints are called
        Example:
        pet_api = PetApi()
        pet_api.add_pet  # this is an instance of the class Endpoint
        pet_api.add_pet()  # this invokes pet_api.add_pet.__call__()
        which then invokes the callable functions stored in that endpoint at
        pet_api.add_pet.callable or self.callable in this class
        """
        return self.callable(self, *args, **kwargs)

    def call_with_http_info(self, **kwargs):

        try:
            index = self.api_client.configuration.server_operation_index.get(
                self.settings['operation_id'], self.api_client.configuration.server_index
            ) if kwargs['_host_index'] is None else kwargs['_host_index']
            server_variables = self.api_client.configuration.server_operation_variables.get(
                self.settings['operation_id'], self.api_client.configuration.server_variables
            )
            _host = self.api_client.configuration.get_host_from_settings(
                index, variables=server_variables, servers=self.settings['servers']
            )
        except IndexError:
            if self.settings['servers']:
                raise ApiValueError(
                    "Invalid host index. Must be 0 <= index < %s" %
                    len(self.settings['servers'])
                )
            _host = None

        for key, value in six.iteritems(kwargs):
            if key not in self.params_map['all']:
                raise ApiTypeError(
                    "Got an unexpected parameter '%s'"
                    " to method `%s`" %
                    (key, self.settings['operation_id'])
                )
            # only throw this nullable ApiValueError if _check_input_type
            # is False, if _check_input_type==True we catch this case
            # in self.__validate_inputs
            if (key not in self.params_map['nullable'] and value is None
                    and kwargs['_check_input_type'] is False):
                raise ApiValueError(
                    "Value may not be None for non-nullable parameter `%s`"
                    " when calling `%s`" %
                    (key, self.settings['operation_id'])
                )

        for key in self.params_map['required']:
            if key not in kwargs.keys():
                raise ApiValueError(
                    "Missing the required parameter `%s` when calling "
                    "`%s`" % (key, self.settings['operation_id'])
                )

        self.__validate_inputs(kwargs)

        params = self.__gather_params(kwargs)
        params['header']['Dd-Operation-Id'] = ''.join(x.title() for x in self.settings['operation_id'].split('_'))

        accept_headers_list = self.headers_map['accept']
        if accept_headers_list:
            params['header']['Accept'] = self.api_client.select_header_accept(
                accept_headers_list)

        content_type_headers_list = self.headers_map['content_type']
        if content_type_headers_list:
            header_list = self.api_client.select_header_content_type(
                content_type_headers_list)
            params['header']['Content-Type'] = header_list

        return self.api_client.call_api(
            self.settings['endpoint_path'], self.settings['http_method'],
            params['path'],
            params['query'],
            params['header'],
            body=params['body'],
            post_params=params['form'],
            files=params['file'],
            response_type=self.settings['response_type'],
            auth_settings=self.settings['auth'],
            async_req=kwargs['async_req'],
            _check_type=kwargs['_check_return_type'],
            _return_http_data_only=kwargs['_return_http_data_only'],
            _preload_content=kwargs['_preload_content'],
            _request_timeout=kwargs['_request_timeout'],
            _host=_host,
            collection_formats=params['collection_format'])

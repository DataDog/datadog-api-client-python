# coding: utf-8

# Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
# This product includes software developed at Datadog (https://www.datadoghq.com/).
# Copyright 2019-Present Datadog, Inc.


import re  # noqa: F401
import sys  # noqa: F401

from datadog_api_client.v1.api_client import ApiClient, Endpoint
from datadog_api_client.v1.model_utils import (  # noqa: F401
    check_allowed_values,
    check_validations,
    date,
    datetime,
    file_type,
    none_type,
    validate_and_convert_types
)
from datadog_api_client.v1.model.api_error_response import APIErrorResponse
from datadog_api_client.v1.model.usage_analyzed_logs_response import UsageAnalyzedLogsResponse
from datadog_api_client.v1.model.usage_billable_summary_response import UsageBillableSummaryResponse
from datadog_api_client.v1.model.usage_custom_reports_response import UsageCustomReportsResponse
from datadog_api_client.v1.model.usage_fargate_response import UsageFargateResponse
from datadog_api_client.v1.model.usage_hosts_response import UsageHostsResponse
from datadog_api_client.v1.model.usage_indexed_spans_response import UsageIndexedSpansResponse
from datadog_api_client.v1.model.usage_ingested_spans_response import UsageIngestedSpansResponse
from datadog_api_client.v1.model.usage_lambda_response import UsageLambdaResponse
from datadog_api_client.v1.model.usage_logs_by_index_response import UsageLogsByIndexResponse
from datadog_api_client.v1.model.usage_logs_response import UsageLogsResponse
from datadog_api_client.v1.model.usage_network_flows_response import UsageNetworkFlowsResponse
from datadog_api_client.v1.model.usage_network_hosts_response import UsageNetworkHostsResponse
from datadog_api_client.v1.model.usage_profiling_response import UsageProfilingResponse
from datadog_api_client.v1.model.usage_rum_sessions_response import UsageRumSessionsResponse
from datadog_api_client.v1.model.usage_snmp_response import UsageSNMPResponse
from datadog_api_client.v1.model.usage_sort import UsageSort
from datadog_api_client.v1.model.usage_sort_direction import UsageSortDirection
from datadog_api_client.v1.model.usage_specified_custom_reports_response import UsageSpecifiedCustomReportsResponse
from datadog_api_client.v1.model.usage_summary_response import UsageSummaryResponse
from datadog_api_client.v1.model.usage_synthetics_api_response import UsageSyntheticsAPIResponse
from datadog_api_client.v1.model.usage_synthetics_browser_response import UsageSyntheticsBrowserResponse
from datadog_api_client.v1.model.usage_synthetics_response import UsageSyntheticsResponse
from datadog_api_client.v1.model.usage_timeseries_response import UsageTimeseriesResponse
from datadog_api_client.v1.model.usage_top_avg_metrics_response import UsageTopAvgMetricsResponse
from datadog_api_client.v1.model.usage_trace_response import UsageTraceResponse
from datadog_api_client.v1.model.usage_tracing_without_limits_response import UsageTracingWithoutLimitsResponse


class UsageMeteringApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

        def __get_daily_custom_reports(
            self,
            **kwargs
        ):
            """Get the list of available daily custom reports  # noqa: E501

            Get daily custom reports.  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.get_daily_custom_reports(async_req=True)
            >>> result = thread.get()


            Keyword Args:
                page_size (int): The number of files to return in the response. &#x60;[default&#x3D;60]&#x60;.. [optional]
                page_number (int): The identifier of the first page to return. This parameter is used for the pagination feature &#x60;[default&#x3D;0]&#x60;.. [optional]
                sort_dir (UsageSortDirection): The direction to sort by: &#x60;[desc, asc]&#x60;.. [optional]
                sort (UsageSort): The field to sort by: &#x60;[computed_on, size, start_date, end_date]&#x60;.. [optional]
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int/None): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                UsageCustomReportsResponse
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            return self.call_with_http_info(**kwargs)

        self.get_daily_custom_reports = Endpoint(
            settings={
                'response_type': (UsageCustomReportsResponse,),
                'auth': [
                    'apiKeyAuth',
                    'appKeyAuth'
                ],
                'endpoint_path': '/api/v1/daily_custom_reports',
                'operation_id': 'get_daily_custom_reports',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'page_size',
                    'page_number',
                    'sort_dir',
                    'sort',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'page_size':
                        (int,),
                    'page_number':
                        (int,),
                    'sort_dir':
                        (UsageSortDirection,),
                    'sort':
                        (UsageSort,),
                },
                'attribute_map': {
                    'page_size': 'page[size]',
                    'page_number': 'page[number]',
                    'sort_dir': 'sort_dir',
                    'sort': 'sort',
                },
                'location_map': {
                    'page_size': 'query',
                    'page_number': 'query',
                    'sort_dir': 'query',
                    'sort': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json;datetime-format=rfc3339'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__get_daily_custom_reports
        )

        def __get_ingested_spans(
            self,
            start_hr,
            **kwargs
        ):
            """Get hourly usage for ingested spans  # noqa: E501

            Get hourly usage for ingested spans.  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.get_ingested_spans(start_hr, async_req=True)
            >>> result = thread.get()

            Args:
                start_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: &#x60;[YYYY-MM-DDThh]&#x60; for usage beginning at this hour.

            Keyword Args:
                end_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: &#x60;[YYYY-MM-DDThh]&#x60; for usage ending **before** this hour.. [optional]
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int/None): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                UsageIngestedSpansResponse
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            kwargs['start_hr'] = \
                start_hr
            return self.call_with_http_info(**kwargs)

        self.get_ingested_spans = Endpoint(
            settings={
                'response_type': (UsageIngestedSpansResponse,),
                'auth': [
                    'apiKeyAuth',
                    'appKeyAuth'
                ],
                'endpoint_path': '/api/v1/usage/ingested-spans',
                'operation_id': 'get_ingested_spans',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'start_hr',
                    'end_hr',
                ],
                'required': [
                    'start_hr',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'start_hr':
                        (datetime,),
                    'end_hr':
                        (datetime,),
                },
                'attribute_map': {
                    'start_hr': 'start_hr',
                    'end_hr': 'end_hr',
                },
                'location_map': {
                    'start_hr': 'query',
                    'end_hr': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json;datetime-format=rfc3339'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__get_ingested_spans
        )

        def __get_monthly_custom_reports(
            self,
            **kwargs
        ):
            """Get the list of available monthly custom reports  # noqa: E501

            Get monthly custom reports.  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.get_monthly_custom_reports(async_req=True)
            >>> result = thread.get()


            Keyword Args:
                page_size (int): The number of files to return in the response &#x60;[default&#x3D;60].&#x60;. [optional]
                page_number (int): The identifier of the first page to return. This parameter is used for the pagination feature &#x60;[default&#x3D;0]&#x60;.. [optional]
                sort_dir (UsageSortDirection): The direction to sort by: &#x60;[desc, asc]&#x60;.. [optional]
                sort (UsageSort): The field to sort by: &#x60;[computed_on, size, start_date, end_date]&#x60;.. [optional]
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int/None): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                UsageCustomReportsResponse
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            return self.call_with_http_info(**kwargs)

        self.get_monthly_custom_reports = Endpoint(
            settings={
                'response_type': (UsageCustomReportsResponse,),
                'auth': [
                    'apiKeyAuth',
                    'appKeyAuth'
                ],
                'endpoint_path': '/api/v1/monthly_custom_reports',
                'operation_id': 'get_monthly_custom_reports',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'page_size',
                    'page_number',
                    'sort_dir',
                    'sort',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'page_size':
                        (int,),
                    'page_number':
                        (int,),
                    'sort_dir':
                        (UsageSortDirection,),
                    'sort':
                        (UsageSort,),
                },
                'attribute_map': {
                    'page_size': 'page[size]',
                    'page_number': 'page[number]',
                    'sort_dir': 'sort_dir',
                    'sort': 'sort',
                },
                'location_map': {
                    'page_size': 'query',
                    'page_number': 'query',
                    'sort_dir': 'query',
                    'sort': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json;datetime-format=rfc3339'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__get_monthly_custom_reports
        )

        def __get_specified_daily_custom_reports(
            self,
            report_id,
            **kwargs
        ):
            """Get specified daily custom reports  # noqa: E501

            Get specified daily custom reports.  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.get_specified_daily_custom_reports(report_id, async_req=True)
            >>> result = thread.get()

            Args:
                report_id (str): The specified ID to search results for.

            Keyword Args:
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int/None): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                UsageSpecifiedCustomReportsResponse
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            kwargs['report_id'] = \
                report_id
            return self.call_with_http_info(**kwargs)

        self.get_specified_daily_custom_reports = Endpoint(
            settings={
                'response_type': (UsageSpecifiedCustomReportsResponse,),
                'auth': [
                    'apiKeyAuth',
                    'appKeyAuth'
                ],
                'endpoint_path': '/api/v1/daily_custom_reports/{report_id}',
                'operation_id': 'get_specified_daily_custom_reports',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'report_id',
                ],
                'required': [
                    'report_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'report_id':
                        (str,),
                },
                'attribute_map': {
                    'report_id': 'report_id',
                },
                'location_map': {
                    'report_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json;datetime-format=rfc3339'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__get_specified_daily_custom_reports
        )

        def __get_specified_monthly_custom_reports(
            self,
            report_id,
            **kwargs
        ):
            """Get specified monthly custom reports  # noqa: E501

            Get specified monthly custom reports.  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.get_specified_monthly_custom_reports(report_id, async_req=True)
            >>> result = thread.get()

            Args:
                report_id (str): The specified ID to search results for.

            Keyword Args:
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int/None): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                UsageSpecifiedCustomReportsResponse
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            kwargs['report_id'] = \
                report_id
            return self.call_with_http_info(**kwargs)

        self.get_specified_monthly_custom_reports = Endpoint(
            settings={
                'response_type': (UsageSpecifiedCustomReportsResponse,),
                'auth': [
                    'apiKeyAuth',
                    'appKeyAuth'
                ],
                'endpoint_path': '/api/v1/monthly_custom_reports/{report_id}',
                'operation_id': 'get_specified_monthly_custom_reports',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'report_id',
                ],
                'required': [
                    'report_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'report_id':
                        (str,),
                },
                'attribute_map': {
                    'report_id': 'report_id',
                },
                'location_map': {
                    'report_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json;datetime-format=rfc3339'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__get_specified_monthly_custom_reports
        )

        def __get_tracing_without_limits(
            self,
            start_hr,
            **kwargs
        ):
            """Get hourly usage for tracing without limits  # noqa: E501

            Get hourly usage for tracing without limits.  **Note** This endpoint has been renamed to `/api/v1/usage/ingested-spans`.  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.get_tracing_without_limits(start_hr, async_req=True)
            >>> result = thread.get()

            Args:
                start_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: &#x60;[YYYY-MM-DDThh]&#x60; for usage beginning at this hour.

            Keyword Args:
                end_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: &#x60;[YYYY-MM-DDThh]&#x60; for usage ending **before** this hour.. [optional]
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int/None): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                UsageTracingWithoutLimitsResponse
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            kwargs['start_hr'] = \
                start_hr
            return self.call_with_http_info(**kwargs)

        self.get_tracing_without_limits = Endpoint(
            settings={
                'response_type': (UsageTracingWithoutLimitsResponse,),
                'auth': [
                    'apiKeyAuth',
                    'appKeyAuth'
                ],
                'endpoint_path': '/api/v1/usage/tracing-without-limits',
                'operation_id': 'get_tracing_without_limits',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'start_hr',
                    'end_hr',
                ],
                'required': [
                    'start_hr',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'start_hr':
                        (datetime,),
                    'end_hr':
                        (datetime,),
                },
                'attribute_map': {
                    'start_hr': 'start_hr',
                    'end_hr': 'end_hr',
                },
                'location_map': {
                    'start_hr': 'query',
                    'end_hr': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json;datetime-format=rfc3339'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__get_tracing_without_limits
        )

        def __get_usage_analyzed_logs(
            self,
            start_hr,
            **kwargs
        ):
            """Get hourly usage for analyzed logs  # noqa: E501

            Get hourly usage for analyzed logs (Security Monitoring).  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.get_usage_analyzed_logs(start_hr, async_req=True)
            >>> result = thread.get()

            Args:
                start_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: &#x60;[YYYY-MM-DDThh]&#x60; for usage beginning at this hour.

            Keyword Args:
                end_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: &#x60;[YYYY-MM-DDThh]&#x60; for usage ending **before** this hour.. [optional]
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int/None): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                UsageAnalyzedLogsResponse
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            kwargs['start_hr'] = \
                start_hr
            return self.call_with_http_info(**kwargs)

        self.get_usage_analyzed_logs = Endpoint(
            settings={
                'response_type': (UsageAnalyzedLogsResponse,),
                'auth': [
                    'apiKeyAuth',
                    'appKeyAuth'
                ],
                'endpoint_path': '/api/v1/usage/analyzed_logs',
                'operation_id': 'get_usage_analyzed_logs',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'start_hr',
                    'end_hr',
                ],
                'required': [
                    'start_hr',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'start_hr':
                        (datetime,),
                    'end_hr':
                        (datetime,),
                },
                'attribute_map': {
                    'start_hr': 'start_hr',
                    'end_hr': 'end_hr',
                },
                'location_map': {
                    'start_hr': 'query',
                    'end_hr': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json;datetime-format=rfc3339'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__get_usage_analyzed_logs
        )

        def __get_usage_billable_summary(
            self,
            **kwargs
        ):
            """Get billable usage across your multi-org account  # noqa: E501

            Get billable usage across your multi-org account.  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.get_usage_billable_summary(async_req=True)
            >>> result = thread.get()


            Keyword Args:
                month (datetime): Datetime in ISO-8601 format, UTC, precise to month: &#x60;[YYYY-MM]&#x60; for usage starting this month.. [optional]
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int/None): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                UsageBillableSummaryResponse
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            return self.call_with_http_info(**kwargs)

        self.get_usage_billable_summary = Endpoint(
            settings={
                'response_type': (UsageBillableSummaryResponse,),
                'auth': [
                    'apiKeyAuth',
                    'appKeyAuth'
                ],
                'endpoint_path': '/api/v1/usage/billable-summary',
                'operation_id': 'get_usage_billable_summary',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'month',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'month':
                        (datetime,),
                },
                'attribute_map': {
                    'month': 'month',
                },
                'location_map': {
                    'month': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json;datetime-format=rfc3339'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__get_usage_billable_summary
        )

        def __get_usage_fargate(
            self,
            start_hr,
            **kwargs
        ):
            """Get hourly usage for Fargate  # noqa: E501

            Get hourly usage for [Fargate](https://docs.datadoghq.com/integrations/ecs_fargate/).  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.get_usage_fargate(start_hr, async_req=True)
            >>> result = thread.get()

            Args:
                start_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage beginning at this hour.

            Keyword Args:
                end_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage ending **before** this hour.. [optional]
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int/None): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                UsageFargateResponse
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            kwargs['start_hr'] = \
                start_hr
            return self.call_with_http_info(**kwargs)

        self.get_usage_fargate = Endpoint(
            settings={
                'response_type': (UsageFargateResponse,),
                'auth': [
                    'apiKeyAuth',
                    'appKeyAuth'
                ],
                'endpoint_path': '/api/v1/usage/fargate',
                'operation_id': 'get_usage_fargate',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'start_hr',
                    'end_hr',
                ],
                'required': [
                    'start_hr',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'start_hr':
                        (datetime,),
                    'end_hr':
                        (datetime,),
                },
                'attribute_map': {
                    'start_hr': 'start_hr',
                    'end_hr': 'end_hr',
                },
                'location_map': {
                    'start_hr': 'query',
                    'end_hr': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json;datetime-format=rfc3339'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__get_usage_fargate
        )

        def __get_usage_hosts(
            self,
            start_hr,
            **kwargs
        ):
            """Get hourly usage for hosts and containers  # noqa: E501

            Get hourly usage for hosts and containers.  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.get_usage_hosts(start_hr, async_req=True)
            >>> result = thread.get()

            Args:
                start_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage beginning at this hour.

            Keyword Args:
                end_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage ending **before** this hour.. [optional]
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int/None): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                UsageHostsResponse
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            kwargs['start_hr'] = \
                start_hr
            return self.call_with_http_info(**kwargs)

        self.get_usage_hosts = Endpoint(
            settings={
                'response_type': (UsageHostsResponse,),
                'auth': [
                    'apiKeyAuth',
                    'appKeyAuth'
                ],
                'endpoint_path': '/api/v1/usage/hosts',
                'operation_id': 'get_usage_hosts',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'start_hr',
                    'end_hr',
                ],
                'required': [
                    'start_hr',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'start_hr':
                        (datetime,),
                    'end_hr':
                        (datetime,),
                },
                'attribute_map': {
                    'start_hr': 'start_hr',
                    'end_hr': 'end_hr',
                },
                'location_map': {
                    'start_hr': 'query',
                    'end_hr': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json;datetime-format=rfc3339'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__get_usage_hosts
        )

        def __get_usage_indexed_spans(
            self,
            start_hr,
            **kwargs
        ):
            """Get hourly usage for indexed spans  # noqa: E501

            Get hourly usage for indexed spans.  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.get_usage_indexed_spans(start_hr, async_req=True)
            >>> result = thread.get()

            Args:
                start_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: &#x60;[YYYY-MM-DDThh]&#x60; for usage beginning at this hour.

            Keyword Args:
                end_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: &#x60;[YYYY-MM-DDThh]&#x60; for usage ending **before** this hour.. [optional]
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int/None): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                UsageIndexedSpansResponse
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            kwargs['start_hr'] = \
                start_hr
            return self.call_with_http_info(**kwargs)

        self.get_usage_indexed_spans = Endpoint(
            settings={
                'response_type': (UsageIndexedSpansResponse,),
                'auth': [
                    'apiKeyAuth',
                    'appKeyAuth'
                ],
                'endpoint_path': '/api/v1/usage/indexed-spans',
                'operation_id': 'get_usage_indexed_spans',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'start_hr',
                    'end_hr',
                ],
                'required': [
                    'start_hr',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'start_hr':
                        (datetime,),
                    'end_hr':
                        (datetime,),
                },
                'attribute_map': {
                    'start_hr': 'start_hr',
                    'end_hr': 'end_hr',
                },
                'location_map': {
                    'start_hr': 'query',
                    'end_hr': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json;datetime-format=rfc3339'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__get_usage_indexed_spans
        )

        def __get_usage_lambda(
            self,
            start_hr,
            **kwargs
        ):
            """Get hourly usage for Lambda  # noqa: E501

            Get hourly usage for lambda.  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.get_usage_lambda(start_hr, async_req=True)
            >>> result = thread.get()

            Args:
                start_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage beginning at this hour.

            Keyword Args:
                end_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage ending **before** this hour.. [optional]
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int/None): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                UsageLambdaResponse
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            kwargs['start_hr'] = \
                start_hr
            return self.call_with_http_info(**kwargs)

        self.get_usage_lambda = Endpoint(
            settings={
                'response_type': (UsageLambdaResponse,),
                'auth': [
                    'apiKeyAuth',
                    'appKeyAuth'
                ],
                'endpoint_path': '/api/v1/usage/aws_lambda',
                'operation_id': 'get_usage_lambda',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'start_hr',
                    'end_hr',
                ],
                'required': [
                    'start_hr',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'start_hr':
                        (datetime,),
                    'end_hr':
                        (datetime,),
                },
                'attribute_map': {
                    'start_hr': 'start_hr',
                    'end_hr': 'end_hr',
                },
                'location_map': {
                    'start_hr': 'query',
                    'end_hr': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json;datetime-format=rfc3339'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__get_usage_lambda
        )

        def __get_usage_logs(
            self,
            start_hr,
            **kwargs
        ):
            """Get hourly usage for Logs  # noqa: E501

            Get hourly usage for logs.  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.get_usage_logs(start_hr, async_req=True)
            >>> result = thread.get()

            Args:
                start_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage beginning at this hour.

            Keyword Args:
                end_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage ending **before** this hour.. [optional]
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int/None): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                UsageLogsResponse
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            kwargs['start_hr'] = \
                start_hr
            return self.call_with_http_info(**kwargs)

        self.get_usage_logs = Endpoint(
            settings={
                'response_type': (UsageLogsResponse,),
                'auth': [
                    'apiKeyAuth',
                    'appKeyAuth'
                ],
                'endpoint_path': '/api/v1/usage/logs',
                'operation_id': 'get_usage_logs',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'start_hr',
                    'end_hr',
                ],
                'required': [
                    'start_hr',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'start_hr':
                        (datetime,),
                    'end_hr':
                        (datetime,),
                },
                'attribute_map': {
                    'start_hr': 'start_hr',
                    'end_hr': 'end_hr',
                },
                'location_map': {
                    'start_hr': 'query',
                    'end_hr': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json;datetime-format=rfc3339'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__get_usage_logs
        )

        def __get_usage_logs_by_index(
            self,
            start_hr,
            **kwargs
        ):
            """Get hourly usage for Logs by Index  # noqa: E501

            Get hourly usage for logs by index.  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.get_usage_logs_by_index(start_hr, async_req=True)
            >>> result = thread.get()

            Args:
                start_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage beginning at this hour.

            Keyword Args:
                end_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage ending **before** this hour.. [optional]
                index_name ([str]): Comma-separated list of log index names.. [optional]
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int/None): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                UsageLogsByIndexResponse
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            kwargs['start_hr'] = \
                start_hr
            return self.call_with_http_info(**kwargs)

        self.get_usage_logs_by_index = Endpoint(
            settings={
                'response_type': (UsageLogsByIndexResponse,),
                'auth': [
                    'apiKeyAuth',
                    'appKeyAuth'
                ],
                'endpoint_path': '/api/v1/usage/logs_by_index',
                'operation_id': 'get_usage_logs_by_index',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'start_hr',
                    'end_hr',
                    'index_name',
                ],
                'required': [
                    'start_hr',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'start_hr':
                        (datetime,),
                    'end_hr':
                        (datetime,),
                    'index_name':
                        ([str],),
                },
                'attribute_map': {
                    'start_hr': 'start_hr',
                    'end_hr': 'end_hr',
                    'index_name': 'index_name',
                },
                'location_map': {
                    'start_hr': 'query',
                    'end_hr': 'query',
                    'index_name': 'query',
                },
                'collection_format_map': {
                    'index_name': 'multi',
                }
            },
            headers_map={
                'accept': [
                    'application/json;datetime-format=rfc3339'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__get_usage_logs_by_index
        )

        def __get_usage_network_flows(
            self,
            start_hr,
            **kwargs
        ):
            """Get hourly usage for Network Flows  # noqa: E501

            Get hourly usage for network flows.  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.get_usage_network_flows(start_hr, async_req=True)
            >>> result = thread.get()

            Args:
                start_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: &#x60;[YYYY-MM-DDThh]&#x60; for usage beginning at this hour.

            Keyword Args:
                end_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: &#x60;[YYYY-MM-DDThh]&#x60; for usage ending **before** this hour.. [optional]
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int/None): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                UsageNetworkFlowsResponse
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            kwargs['start_hr'] = \
                start_hr
            return self.call_with_http_info(**kwargs)

        self.get_usage_network_flows = Endpoint(
            settings={
                'response_type': (UsageNetworkFlowsResponse,),
                'auth': [
                    'apiKeyAuth',
                    'appKeyAuth'
                ],
                'endpoint_path': '/api/v1/usage/network_flows',
                'operation_id': 'get_usage_network_flows',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'start_hr',
                    'end_hr',
                ],
                'required': [
                    'start_hr',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'start_hr':
                        (datetime,),
                    'end_hr':
                        (datetime,),
                },
                'attribute_map': {
                    'start_hr': 'start_hr',
                    'end_hr': 'end_hr',
                },
                'location_map': {
                    'start_hr': 'query',
                    'end_hr': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json;datetime-format=rfc3339'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__get_usage_network_flows
        )

        def __get_usage_network_hosts(
            self,
            start_hr,
            **kwargs
        ):
            """Get hourly usage for Network Hosts  # noqa: E501

            Get hourly usage for network hosts.  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.get_usage_network_hosts(start_hr, async_req=True)
            >>> result = thread.get()

            Args:
                start_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage beginning at this hour.

            Keyword Args:
                end_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage ending **before** this hour.. [optional]
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int/None): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                UsageNetworkHostsResponse
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            kwargs['start_hr'] = \
                start_hr
            return self.call_with_http_info(**kwargs)

        self.get_usage_network_hosts = Endpoint(
            settings={
                'response_type': (UsageNetworkHostsResponse,),
                'auth': [
                    'apiKeyAuth',
                    'appKeyAuth'
                ],
                'endpoint_path': '/api/v1/usage/network_hosts',
                'operation_id': 'get_usage_network_hosts',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'start_hr',
                    'end_hr',
                ],
                'required': [
                    'start_hr',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'start_hr':
                        (datetime,),
                    'end_hr':
                        (datetime,),
                },
                'attribute_map': {
                    'start_hr': 'start_hr',
                    'end_hr': 'end_hr',
                },
                'location_map': {
                    'start_hr': 'query',
                    'end_hr': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json;datetime-format=rfc3339'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__get_usage_network_hosts
        )

        def __get_usage_profiling(
            self,
            start_hr,
            **kwargs
        ):
            """Get hourly usage for profiled hosts  # noqa: E501

            Get hourly usage for profiled hosts.  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.get_usage_profiling(start_hr, async_req=True)
            >>> result = thread.get()

            Args:
                start_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: &#x60;[YYYY-MM-DDThh]&#x60; for usage beginning at this hour.

            Keyword Args:
                end_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: &#x60;[YYYY-MM-DDThh]&#x60; for usage ending **before** this hour.. [optional]
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int/None): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                UsageProfilingResponse
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            kwargs['start_hr'] = \
                start_hr
            return self.call_with_http_info(**kwargs)

        self.get_usage_profiling = Endpoint(
            settings={
                'response_type': (UsageProfilingResponse,),
                'auth': [
                    'apiKeyAuth',
                    'appKeyAuth'
                ],
                'endpoint_path': '/api/v1/usage/profiling',
                'operation_id': 'get_usage_profiling',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'start_hr',
                    'end_hr',
                ],
                'required': [
                    'start_hr',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'start_hr':
                        (datetime,),
                    'end_hr':
                        (datetime,),
                },
                'attribute_map': {
                    'start_hr': 'start_hr',
                    'end_hr': 'end_hr',
                },
                'location_map': {
                    'start_hr': 'query',
                    'end_hr': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json;datetime-format=rfc3339'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__get_usage_profiling
        )

        def __get_usage_rum_sessions(
            self,
            start_hr,
            **kwargs
        ):
            """Get hourly usage for RUM Sessions  # noqa: E501

            Get hourly usage for [RUM](https://docs.datadoghq.com/real_user_monitoring/) Sessions.  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.get_usage_rum_sessions(start_hr, async_req=True)
            >>> result = thread.get()

            Args:
                start_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage beginning at this hour.

            Keyword Args:
                end_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage ending **before** this hour.. [optional]
                type (str): RUM type: &#x60;[browser, mobile]&#x60;. Defaults to &#x60;browser&#x60;.. [optional]
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int/None): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                UsageRumSessionsResponse
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            kwargs['start_hr'] = \
                start_hr
            return self.call_with_http_info(**kwargs)

        self.get_usage_rum_sessions = Endpoint(
            settings={
                'response_type': (UsageRumSessionsResponse,),
                'auth': [
                    'apiKeyAuth',
                    'appKeyAuth'
                ],
                'endpoint_path': '/api/v1/usage/rum_sessions',
                'operation_id': 'get_usage_rum_sessions',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'start_hr',
                    'end_hr',
                    'type',
                ],
                'required': [
                    'start_hr',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'start_hr':
                        (datetime,),
                    'end_hr':
                        (datetime,),
                    'type':
                        (str,),
                },
                'attribute_map': {
                    'start_hr': 'start_hr',
                    'end_hr': 'end_hr',
                    'type': 'type',
                },
                'location_map': {
                    'start_hr': 'query',
                    'end_hr': 'query',
                    'type': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json;datetime-format=rfc3339'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__get_usage_rum_sessions
        )

        def __get_usage_snmp(
            self,
            start_hr,
            **kwargs
        ):
            """Get hourly usage for SNMP devices  # noqa: E501

            Get hourly usage for SNMP devices.  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.get_usage_snmp(start_hr, async_req=True)
            >>> result = thread.get()

            Args:
                start_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: &#x60;[YYYY-MM-DDThh]&#x60; for usage beginning at this hour.

            Keyword Args:
                end_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: &#x60;[YYYY-MM-DDThh]&#x60; for usage ending **before** this hour.. [optional]
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int/None): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                UsageSNMPResponse
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            kwargs['start_hr'] = \
                start_hr
            return self.call_with_http_info(**kwargs)

        self.get_usage_snmp = Endpoint(
            settings={
                'response_type': (UsageSNMPResponse,),
                'auth': [
                    'apiKeyAuth',
                    'appKeyAuth'
                ],
                'endpoint_path': '/api/v1/usage/snmp',
                'operation_id': 'get_usage_snmp',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'start_hr',
                    'end_hr',
                ],
                'required': [
                    'start_hr',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'start_hr':
                        (datetime,),
                    'end_hr':
                        (datetime,),
                },
                'attribute_map': {
                    'start_hr': 'start_hr',
                    'end_hr': 'end_hr',
                },
                'location_map': {
                    'start_hr': 'query',
                    'end_hr': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json;datetime-format=rfc3339'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__get_usage_snmp
        )

        def __get_usage_summary(
            self,
            start_month,
            **kwargs
        ):
            """Get usage across your multi-org account  # noqa: E501

            Get usage across your multi-org account.  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.get_usage_summary(start_month, async_req=True)
            >>> result = thread.get()

            Args:
                start_month (datetime): Datetime in ISO-8601 format, UTC, precise to month: &#x60;[YYYY-MM]&#x60; for usage beginning in this month. Maximum of 15 months ago.

            Keyword Args:
                end_month (datetime): Datetime in ISO-8601 format, UTC, precise to month: &#x60;[YYYY-MM]&#x60; for usage ending this month.. [optional]
                include_org_details (bool): Include usage summaries for each sub-org.. [optional]
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int/None): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                UsageSummaryResponse
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            kwargs['start_month'] = \
                start_month
            return self.call_with_http_info(**kwargs)

        self.get_usage_summary = Endpoint(
            settings={
                'response_type': (UsageSummaryResponse,),
                'auth': [
                    'apiKeyAuth',
                    'appKeyAuth'
                ],
                'endpoint_path': '/api/v1/usage/summary',
                'operation_id': 'get_usage_summary',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'start_month',
                    'end_month',
                    'include_org_details',
                ],
                'required': [
                    'start_month',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'start_month':
                        (datetime,),
                    'end_month':
                        (datetime,),
                    'include_org_details':
                        (bool,),
                },
                'attribute_map': {
                    'start_month': 'start_month',
                    'end_month': 'end_month',
                    'include_org_details': 'include_org_details',
                },
                'location_map': {
                    'start_month': 'query',
                    'end_month': 'query',
                    'include_org_details': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json;datetime-format=rfc3339'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__get_usage_summary
        )

        def __get_usage_synthetics(
            self,
            start_hr,
            **kwargs
        ):
            """Get hourly usage for Synthetics Checks  # noqa: E501

            Get hourly usage for [Synthetics checks](https://docs.datadoghq.com/synthetics/).  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.get_usage_synthetics(start_hr, async_req=True)
            >>> result = thread.get()

            Args:
                start_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage beginning at this hour.

            Keyword Args:
                end_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage ending **before** this hour.. [optional]
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int/None): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                UsageSyntheticsResponse
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            kwargs['start_hr'] = \
                start_hr
            return self.call_with_http_info(**kwargs)

        self.get_usage_synthetics = Endpoint(
            settings={
                'response_type': (UsageSyntheticsResponse,),
                'auth': [
                    'apiKeyAuth',
                    'appKeyAuth'
                ],
                'endpoint_path': '/api/v1/usage/synthetics',
                'operation_id': 'get_usage_synthetics',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'start_hr',
                    'end_hr',
                ],
                'required': [
                    'start_hr',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'start_hr':
                        (datetime,),
                    'end_hr':
                        (datetime,),
                },
                'attribute_map': {
                    'start_hr': 'start_hr',
                    'end_hr': 'end_hr',
                },
                'location_map': {
                    'start_hr': 'query',
                    'end_hr': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json;datetime-format=rfc3339'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__get_usage_synthetics
        )

        def __get_usage_synthetics_api(
            self,
            start_hr,
            **kwargs
        ):
            """Get hourly usage for Synthetics API Checks  # noqa: E501

            Get hourly usage for [synthetics API checks](https://docs.datadoghq.com/synthetics/).  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.get_usage_synthetics_api(start_hr, async_req=True)
            >>> result = thread.get()

            Args:
                start_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage beginning at this hour.

            Keyword Args:
                end_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage ending **before** this hour.. [optional]
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int/None): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                UsageSyntheticsAPIResponse
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            kwargs['start_hr'] = \
                start_hr
            return self.call_with_http_info(**kwargs)

        self.get_usage_synthetics_api = Endpoint(
            settings={
                'response_type': (UsageSyntheticsAPIResponse,),
                'auth': [
                    'apiKeyAuth',
                    'appKeyAuth'
                ],
                'endpoint_path': '/api/v1/usage/synthetics_api',
                'operation_id': 'get_usage_synthetics_api',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'start_hr',
                    'end_hr',
                ],
                'required': [
                    'start_hr',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'start_hr':
                        (datetime,),
                    'end_hr':
                        (datetime,),
                },
                'attribute_map': {
                    'start_hr': 'start_hr',
                    'end_hr': 'end_hr',
                },
                'location_map': {
                    'start_hr': 'query',
                    'end_hr': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json;datetime-format=rfc3339'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__get_usage_synthetics_api
        )

        def __get_usage_synthetics_browser(
            self,
            start_hr,
            **kwargs
        ):
            """Get hourly usage for Synthetics Browser Checks  # noqa: E501

            Get hourly usage for synthetics browser checks.  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.get_usage_synthetics_browser(start_hr, async_req=True)
            >>> result = thread.get()

            Args:
                start_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage beginning at this hour.

            Keyword Args:
                end_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage ending **before** this hour.. [optional]
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int/None): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                UsageSyntheticsBrowserResponse
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            kwargs['start_hr'] = \
                start_hr
            return self.call_with_http_info(**kwargs)

        self.get_usage_synthetics_browser = Endpoint(
            settings={
                'response_type': (UsageSyntheticsBrowserResponse,),
                'auth': [
                    'apiKeyAuth',
                    'appKeyAuth'
                ],
                'endpoint_path': '/api/v1/usage/synthetics_browser',
                'operation_id': 'get_usage_synthetics_browser',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'start_hr',
                    'end_hr',
                ],
                'required': [
                    'start_hr',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'start_hr':
                        (datetime,),
                    'end_hr':
                        (datetime,),
                },
                'attribute_map': {
                    'start_hr': 'start_hr',
                    'end_hr': 'end_hr',
                },
                'location_map': {
                    'start_hr': 'query',
                    'end_hr': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json;datetime-format=rfc3339'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__get_usage_synthetics_browser
        )

        def __get_usage_timeseries(
            self,
            start_hr,
            **kwargs
        ):
            """Get hourly usage for custom metrics  # noqa: E501

            Get hourly usage for [custom metrics](https://docs.datadoghq.com/developers/metrics/custom_metrics/).  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.get_usage_timeseries(start_hr, async_req=True)
            >>> result = thread.get()

            Args:
                start_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage beginning at this hour.

            Keyword Args:
                end_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage ending **before** this hour.. [optional]
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int/None): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                UsageTimeseriesResponse
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            kwargs['start_hr'] = \
                start_hr
            return self.call_with_http_info(**kwargs)

        self.get_usage_timeseries = Endpoint(
            settings={
                'response_type': (UsageTimeseriesResponse,),
                'auth': [
                    'apiKeyAuth',
                    'appKeyAuth'
                ],
                'endpoint_path': '/api/v1/usage/timeseries',
                'operation_id': 'get_usage_timeseries',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'start_hr',
                    'end_hr',
                ],
                'required': [
                    'start_hr',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'start_hr':
                        (datetime,),
                    'end_hr':
                        (datetime,),
                },
                'attribute_map': {
                    'start_hr': 'start_hr',
                    'end_hr': 'end_hr',
                },
                'location_map': {
                    'start_hr': 'query',
                    'end_hr': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json;datetime-format=rfc3339'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__get_usage_timeseries
        )

        def __get_usage_top_avg_metrics(
            self,
            month,
            **kwargs
        ):
            """Get top 500 custom metrics by hourly average  # noqa: E501

            Get top [custom metrics](https://docs.datadoghq.com/developers/metrics/custom_metrics/) by hourly average.  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.get_usage_top_avg_metrics(month, async_req=True)
            >>> result = thread.get()

            Args:
                month (datetime): Datetime in ISO-8601 format, UTC, precise to month: [YYYY-MM] for usage beginning at this hour.

            Keyword Args:
                names ([str]): Comma-separated list of metric names.. [optional]
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int/None): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                UsageTopAvgMetricsResponse
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            kwargs['month'] = \
                month
            return self.call_with_http_info(**kwargs)

        self.get_usage_top_avg_metrics = Endpoint(
            settings={
                'response_type': (UsageTopAvgMetricsResponse,),
                'auth': [
                    'apiKeyAuth',
                    'appKeyAuth'
                ],
                'endpoint_path': '/api/v1/usage/top_avg_metrics',
                'operation_id': 'get_usage_top_avg_metrics',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'month',
                    'names',
                ],
                'required': [
                    'month',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'month':
                        (datetime,),
                    'names':
                        ([str],),
                },
                'attribute_map': {
                    'month': 'month',
                    'names': 'names',
                },
                'location_map': {
                    'month': 'query',
                    'names': 'query',
                },
                'collection_format_map': {
                    'names': 'multi',
                }
            },
            headers_map={
                'accept': [
                    'application/json;datetime-format=rfc3339'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__get_usage_top_avg_metrics
        )

        def __get_usage_trace(
            self,
            start_hr,
            **kwargs
        ):
            """Get hourly usage for Trace Search  # noqa: E501

            Get hourly usage for trace search.  **Note** This endpoint has been renamed to `/api/v1/usage/indexed-spans`.  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.get_usage_trace(start_hr, async_req=True)
            >>> result = thread.get()

            Args:
                start_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage beginning at this hour.

            Keyword Args:
                end_hr (datetime): Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage ending **before** this hour.. [optional]
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int/None): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                UsageTraceResponse
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            kwargs['start_hr'] = \
                start_hr
            return self.call_with_http_info(**kwargs)

        self.get_usage_trace = Endpoint(
            settings={
                'response_type': (UsageTraceResponse,),
                'auth': [
                    'apiKeyAuth',
                    'appKeyAuth'
                ],
                'endpoint_path': '/api/v1/usage/traces',
                'operation_id': 'get_usage_trace',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'start_hr',
                    'end_hr',
                ],
                'required': [
                    'start_hr',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'start_hr':
                        (datetime,),
                    'end_hr':
                        (datetime,),
                },
                'attribute_map': {
                    'start_hr': 'start_hr',
                    'end_hr': 'end_hr',
                },
                'location_map': {
                    'start_hr': 'query',
                    'end_hr': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json;datetime-format=rfc3339'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__get_usage_trace
        )
